#!/usr/bin/env python
"""
    Marko Pinteric 2023

    SSD1680 epaper controller
        - fast SPI communication using C code
        - requires spi.so in the same folder
        - data for fast transfer have to be supplied in contiguous block of bytes
        - put spidev.bufsiz=65536 to the end of the line in /boot/cmdline.txt to allow large SPI transfers

    for more information see: http://www.pinteric.com/displays.html
"""

import os, numpy, time
from ctypes import cdll, c_int, c_uint, c_uint32, c_void_p

###### Wrapping C library ######
spi = cdll.LoadLibrary("./spi.so")

"""
gpioInitialise()

Initialise GPIO bus.
"""
gpioInitialise =  spi.gpioInitialise

"""
gpioSetMode(gpio, mode)

Set the GPIO mode.
"""
PI_INPUT = 0
PI_OUTPUT = 1
gpioSetMode = spi.gpioSetMode
gpioSetMode.argtypes = [c_uint, c_uint]

"""
gpioRead(gpio)

Read from GPIO.
"""
gpioRead = spi.gpioRead
gpioRead.argtypes = [c_uint]

"""
gpioWrite(gpio, level)

Write to GPIO.
"""
gpioWrite = spi.gpioWrite
gpioWrite.argtypes = [c_uint, c_uint]

"""
spiInitialise()

Initialise SPI bus.
"""
spiInitialise = spi.spiInitialise
spiInitialise.argtypes = [c_int, c_uint32]

"""
spiWrite()

Write to SPI.
"""
spiWrite = spi.spiWrite
spiWrite.argtypes = [c_void_p, c_int]

##### MONOSPACE FONT #####
# Plotter font, https://damieng.com/typography/zx-origins/plotter/
ASCII = {
' ': numpy.array([0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00], dtype = 'uint8'),
'!': numpy.array([0x00,0x00,0x00,0xFA,0x00,0x00,0x00,0x00], dtype = 'uint8'),
'"': numpy.array([0x00,0x00,0xC0,0x00,0x00,0xC0,0x00,0x00], dtype = 'uint8'),
'#': numpy.array([0x00,0x24,0x7E,0x24,0x24,0x7E,0x24,0x00], dtype = 'uint8'),
'$': numpy.array([0x24,0x52,0x52,0xFF,0x4A,0x4A,0x24,0x00], dtype = 'uint8'),
'%': numpy.array([0x40,0xA4,0x48,0x10,0x24,0x4A,0x04,0x00], dtype = 'uint8'),
'&': numpy.array([0x6C,0x92,0x92,0x92,0x6A,0x04,0x0A,0x00], dtype = 'uint8'),
'\'': numpy.array([0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00], dtype = 'uint8'),
'(': numpy.array([0x00,0x00,0x00,0x38,0x44,0x82,0x00,0x00], dtype = 'uint8'),
')': numpy.array([0x00,0x00,0x82,0x44,0x38,0x00,0x00,0x00], dtype = 'uint8'),
'*': numpy.array([0x00,0x48,0x30,0xFC,0x30,0x48,0x00,0x00], dtype = 'uint8'),
'+': numpy.array([0x00,0x10,0x10,0x7C,0x10,0x10,0x00,0x00], dtype = 'uint8'),
',': numpy.array([0x00,0x00,0x01,0x02,0x00,0x00,0x00,0x00], dtype = 'uint8'),
'-': numpy.array([0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x00], dtype = 'uint8'),
'.': numpy.array([0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00], dtype = 'uint8'),
'/': numpy.array([0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x00], dtype = 'uint8'),
'0': numpy.array([0x3A,0x44,0x8A,0x92,0xA2,0x44,0xB8,0x00], dtype = 'uint8'),
'1': numpy.array([0x00,0x00,0x00,0x40,0xFE,0x00,0x00,0x00], dtype = 'uint8'),
'2': numpy.array([0x46,0x8A,0x8A,0x92,0x92,0x92,0x62,0x00], dtype = 'uint8'),
'3': numpy.array([0x84,0x82,0x82,0x92,0x92,0xB2,0xCC,0x00], dtype = 'uint8'),
'4': numpy.array([0x0C,0x14,0x24,0x44,0x84,0x1E,0x04,0x00], dtype = 'uint8'),
'5': numpy.array([0xE4,0xA2,0xA2,0xA2,0xA2,0xA2,0x9C,0x00], dtype = 'uint8'),
'6': numpy.array([0x3C,0x52,0x92,0x92,0x92,0x92,0x0C,0x00], dtype = 'uint8'),
'7': numpy.array([0x80,0x82,0x84,0x88,0x90,0xA0,0xC0,0x00], dtype = 'uint8'),
'8': numpy.array([0x6C,0x92,0x92,0x92,0x92,0x92,0x6C,0x00], dtype = 'uint8'),
'9': numpy.array([0x60,0x92,0x92,0x92,0x92,0x94,0x78,0x00], dtype = 'uint8'),
':': numpy.array([0x00,0x00,0x00,0x24,0x00,0x00,0x00,0x00], dtype = 'uint8'),
';': numpy.array([0x00,0x00,0x02,0x24,0x00,0x00,0x00,0x00], dtype = 'uint8'),
'<': numpy.array([0x00,0x00,0x10,0x28,0x44,0x82,0x00,0x00], dtype = 'uint8'),
'=': numpy.array([0x00,0x28,0x28,0x28,0x28,0x28,0x28,0x00], dtype = 'uint8'),
'>': numpy.array([0x00,0x00,0x82,0x44,0x28,0x10,0x00,0x00], dtype = 'uint8'),
'?': numpy.array([0x40,0x80,0x80,0x8A,0x90,0x90,0x60,0x00], dtype = 'uint8'),
'@': numpy.array([0x00,0x4C,0x92,0x94,0xBE,0x82,0x7E,0x00], dtype = 'uint8'),
'A': numpy.array([0x06,0x18,0x68,0x88,0x68,0x18,0x06,0x00], dtype = 'uint8'),
'B': numpy.array([0xFE,0x92,0x92,0x92,0x92,0x92,0x6C,0x00], dtype = 'uint8'),
'C': numpy.array([0x38,0x44,0x82,0x82,0x82,0x82,0x44,0x00], dtype = 'uint8'),
'D': numpy.array([0xFE,0x82,0x82,0x82,0x82,0x44,0x38,0x00], dtype = 'uint8'),
'E': numpy.array([0xFE,0x92,0x92,0x92,0x92,0x92,0x82,0x00], dtype = 'uint8'),
'F': numpy.array([0xFE,0x90,0x90,0x90,0x90,0x90,0x80,0x00], dtype = 'uint8'),
'G': numpy.array([0x38,0x44,0x82,0x82,0x92,0x92,0x5E,0x00], dtype = 'uint8'),
'H': numpy.array([0xFE,0x10,0x10,0x10,0x10,0x10,0xFE,0x00], dtype = 'uint8'),
'I': numpy.array([0x00,0x82,0x82,0xFE,0x82,0x82,0x00,0x00], dtype = 'uint8'),
'J': numpy.array([0x0C,0x02,0x02,0x02,0x02,0x04,0xF8,0x00], dtype = 'uint8'),
'K': numpy.array([0xFE,0x10,0x10,0x10,0x28,0x44,0x82,0x00], dtype = 'uint8'),
'L': numpy.array([0xFE,0x02,0x02,0x02,0x02,0x02,0x02,0x00], dtype = 'uint8'),
'M': numpy.array([0xFE,0x40,0x20,0x10,0x20,0x40,0xFE,0x00], dtype = 'uint8'),
'N': numpy.array([0xFE,0x40,0x20,0x10,0x08,0x04,0xFE,0x00], dtype = 'uint8'),
'O': numpy.array([0x38,0x44,0x82,0x82,0x82,0x44,0x38,0x00], dtype = 'uint8'),
'P': numpy.array([0xFE,0x88,0x88,0x88,0x88,0x88,0x70,0x00], dtype = 'uint8'),
'Q': numpy.array([0x38,0x44,0x82,0x82,0x8A,0x44,0x3A,0x00], dtype = 'uint8'),
'R': numpy.array([0xFE,0x88,0x88,0x88,0x88,0x8C,0x72,0x00], dtype = 'uint8'),
'S': numpy.array([0x64,0x92,0x92,0x92,0x92,0x92,0x4C,0x00], dtype = 'uint8'),
'T': numpy.array([0x80,0x80,0x80,0xFE,0x80,0x80,0x80,0x00], dtype = 'uint8'),
'U': numpy.array([0xFC,0x02,0x02,0x02,0x02,0x02,0xFC,0x00], dtype = 'uint8'),
'V': numpy.array([0xC0,0x30,0x0C,0x02,0x0C,0x30,0xC0,0x00], dtype = 'uint8'),
'W': numpy.array([0xFC,0x02,0x04,0x08,0x04,0x02,0xFC,0x00], dtype = 'uint8'),
'X': numpy.array([0x82,0x44,0x28,0x10,0x28,0x44,0x82,0x00], dtype = 'uint8'),
'Y': numpy.array([0xC0,0x20,0x10,0x0E,0x10,0x20,0xC0,0x00], dtype = 'uint8'),
'Z': numpy.array([0x82,0x86,0x8A,0x92,0xA2,0xC2,0x82,0x00], dtype = 'uint8'),
'[': numpy.array([0x00,0xFE,0x82,0x82,0x00,0x00,0x00,0x00], dtype = 'uint8'),
'\\': numpy.array([0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x00], dtype = 'uint8'),
']': numpy.array([0x00,0x82,0x82,0xFE,0x00,0x00,0x00,0x00], dtype = 'uint8'),
'^': numpy.array([0x00,0x20,0x40,0x80,0x40,0x20,0x00,0x00], dtype = 'uint8'),
'_': numpy.array([0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01], dtype = 'uint8'),
'`': numpy.array([0x12,0x7E,0x92,0x92,0x92,0x82,0x42,0x00], dtype = 'uint8'),
'a': numpy.array([0x04,0x2A,0x2A,0x2A,0x2A,0x2A,0x1E,0x00], dtype = 'uint8'),
'b': numpy.array([0xFE,0x14,0x22,0x22,0x22,0x22,0x1C,0x00], dtype = 'uint8'),
'c': numpy.array([0x1C,0x22,0x22,0x22,0x22,0x22,0x14,0x00], dtype = 'uint8'),
'd': numpy.array([0x1C,0x22,0x22,0x22,0x22,0x14,0xFE,0x00], dtype = 'uint8'),
'e': numpy.array([0x1C,0x2A,0x2A,0x2A,0x2A,0x2A,0x12,0x00], dtype = 'uint8'),
'f': numpy.array([0x10,0x10,0x7E,0x90,0x90,0x80,0x40,0x00], dtype = 'uint8'),
'g': numpy.array([0x19,0x25,0x25,0x25,0x25,0x25,0x3E,0x00], dtype = 'uint8'),
'h': numpy.array([0xFE,0x10,0x20,0x20,0x20,0x20,0x1E,0x00], dtype = 'uint8'),
'i': numpy.array([0x00,0x00,0x00,0xBE,0x00,0x00,0x00,0x00], dtype = 'uint8'),
'j': numpy.array([0x06,0x01,0x01,0x01,0x01,0x01,0xBE,0x00], dtype = 'uint8'),
'k': numpy.array([0xFE,0x08,0x08,0x14,0x14,0x22,0x22,0x00], dtype = 'uint8'),
'l': numpy.array([0x00,0x80,0x80,0xFE,0x00,0x00,0x00,0x00], dtype = 'uint8'),
'm': numpy.array([0x3E,0x20,0x20,0x1E,0x20,0x20,0x1E,0x00], dtype = 'uint8'),
'n': numpy.array([0x3E,0x10,0x20,0x20,0x20,0x20,0x1E,0x00], dtype = 'uint8'),
'o': numpy.array([0x1C,0x22,0x22,0x22,0x22,0x22,0x1C,0x00], dtype = 'uint8'),
'p': numpy.array([0x3F,0x14,0x22,0x22,0x22,0x22,0x1C,0x00], dtype = 'uint8'),
'q': numpy.array([0x1C,0x22,0x22,0x22,0x22,0x14,0x3F,0x00], dtype = 'uint8'),
'r': numpy.array([0x3E,0x10,0x20,0x20,0x20,0x20,0x10,0x00], dtype = 'uint8'),
's': numpy.array([0x12,0x2A,0x2A,0x2A,0x2A,0x2A,0x24,0x00], dtype = 'uint8'),
't': numpy.array([0x20,0x20,0xFC,0x22,0x22,0x02,0x02,0x00], dtype = 'uint8'),
'u': numpy.array([0x3C,0x02,0x02,0x02,0x02,0x04,0x3E,0x00], dtype = 'uint8'),
'v': numpy.array([0x30,0x08,0x04,0x02,0x04,0x08,0x30,0x00], dtype = 'uint8'),
'w': numpy.array([0x30,0x0C,0x02,0x0C,0x02,0x0C,0x30,0x00], dtype = 'uint8'),
'x': numpy.array([0x22,0x22,0x14,0x08,0x14,0x22,0x22,0x00], dtype = 'uint8'),
'y': numpy.array([0x30,0x09,0x05,0x02,0x04,0x08,0x30,0x00], dtype = 'uint8'),
'z': numpy.array([0x00,0x22,0x26,0x2A,0x2A,0x32,0x22,0x00], dtype = 'uint8'),
'{': numpy.array([0x00,0x10,0x10,0x6C,0x82,0x82,0x82,0x00], dtype = 'uint8'),
'|': numpy.array([0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00], dtype = 'uint8'),
'}': numpy.array([0x00,0x82,0x82,0x82,0x6C,0x10,0x10,0x00], dtype = 'uint8'),
'~': numpy.array([0x00,0x60,0x80,0xC0,0x60,0x20,0xC0,0x00], dtype = 'uint8'),
}

# LUT for a single colour refresh, obtained from WaveShare
lut_black = numpy.array([
0x80,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,
0x10,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,
0x80,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,
0x10,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x14,0x08,0x00,0x00,0x00,0x00,0x02,
0x0A,0x0A,0x00,0x0A,0x0A,0x00,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x14,0x08,0x00,0x01,0x00,0x00,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x44,0x44,0x44,0x44,0x44,0x44,0x00,0x00,0x00], dtype = 'uint8')

# LUT for a fast partial refresh
lut_partial = numpy.array([
0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x40,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x0A,0x00,0x00,0x00,0x00,0x00,0x02,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x22,0x22,0x22,0x22,0x22,0x22,0x00,0x00,0x00], dtype = 'uint8')

##### SSD1680 FUNCTIONS #####
class SSD1680(object):
    def __init__(self, dc, res, busy, dev=0, frequency=20000000):
        self._dc  = dc
        self._res = res
        self._busy = busy

        # Initialise GPIO
        gpioInitialise()
        gpioSetMode(dc, PI_OUTPUT)
        gpioSetMode(res, PI_OUTPUT)
        gpioSetMode(busy, PI_INPUT)

        # Initialise SPI
        spiInitialise(dev, frequency)

        # define buffers for white (negative black) and red pixels
        self.white = numpy.full(296*128//8, 0xFF, dtype='uint8')
        self.red = numpy.full(296*128//8, 0x00, dtype='uint8')

        # chip reset
        gpioWrite(dc,1)

        gpioWrite(res,1)
        time.sleep(0.05)
        gpioWrite(res,0)
        time.sleep(0.05)
        gpioWrite(res,1)
        while(gpioRead(busy)==1): time.sleep(0.001)

        self.command(0x01,[0x27,0x01,0x01])      # Driver output control (default 0x270100)
        self.command(0x3C,[0x05])                # BorderWavefrom (default 0xC0)
        self.command(0x21,[0x00,0x80])           # Display update control
        self.command(0x18,[0x80])                # Read built-in temperature sensor

        self.command(0x11,[0x03])                # Address mode: top to bottom, left to right
        self.command(0x44,[0x00,0x0F])           # X address range
        self.command(0x45,[0x00,0x00,0x27,0x01]) # Y address range
        self.command(0x4E,[0x00])                # X address start
        self.command(0x4F,[0x00,0x00])           # Y address start
        
    def command(self, nam, dat=[]):
        gpioWrite(self._dc,0)
        nam=numpy.array([nam], dtype = 'uint8')
        spiWrite(nam.ctypes.data_as(c_void_p),len(nam))
        gpioWrite(self._dc,1)
        if len(dat)>0:
            if(type(dat)!=numpy.ndarray):
                dat=numpy.array(dat, dtype = 'uint8')
            spiWrite(dat.ctypes.data_as(c_void_p),len(dat))

    # write a monospaced font ASCII text, parameter: text, alignment ('l', 'c', 'r'), first line
    def message_m(self, text, align, first = 0):
        # adapt the text
        lines=text.split("\n")
        for i in range(0,len(lines)):
            # calculate front and end space
            add = 296//8-len(lines[i])
            if align=='l':
                addl = 0
                addr = add
            elif align=='r':
                addl = add
                addr = 0
            elif align=='c':
                addr = add//2
                addl = add-addr
            else: print('Wrong alignment: ' + align)
            # put the text to line buffer
            lstr=i+first
            for j in range(addl):
                for k in range(8):
                    self.white[lstr] = ~0x00
                    lstr = lstr+128//8
            for j in range(0,len(lines[i])):
                for k in range(8):
                    self.white[lstr] = ~ASCII[lines[i][j]][k]
                    lstr = lstr+128//8
            for j in range(addr):
                for k in range(8):
                    self.white[lstr] = ~0x00
                    lstr = lstr+128//8

    # Display Update Sequence:
    # 0b10000000 enable clock
    # 0b01000000 enable analog
    # 0b00100000 load temperature value
    # 0b00010000 load default LUT
    # 0b00001000 display mode 1 or 2
    # 0b00000100 display
    # 0b00000010 disable analog
    # 0b00000001 disable clock

    def display(self):
        self.command(0x24,self.white)            # Load negative black picture
        while(gpioRead(self._busy)==1): time.sleep(0.001)
        self.command(0x26,self.red)              # Load red picture
        while(gpioRead(self._busy)==1): time.sleep(0.001)
        self.command(0x22,[0xF7])                # Sequance: load producer-defined LUT and display
        self.command(0x20)                       # Activate Display Update Sequence
        while(gpioRead(self._busy)==1): time.sleep(0.001)

    def display_black(self):
        self.command(0x24,self.white)            # load negative black picture
        while(gpioRead(self._busy)==1): time.sleep(0.001)
        self.command(0x32,lut_black)             # Load user-defined LUT for black-only display
        while(gpioRead(self._busy)==1): time.sleep(0.001)
        self.command(0x22,[0xC7])                # Sequence: display
        self.command(0x20)                       # Activate Display Update Sequence
        while(gpioRead(self._busy)==1): time.sleep(0.001)

    def display_partial(self):
        self.command(0x24,self.white)            # load negative black picture
        while(gpioRead(self._busy)==1): time.sleep(0.001)
        self.command(0x32,lut_partial)           # Load user-defined LUT for partial refresh
        while(gpioRead(self._busy)==1): time.sleep(0.001)
        self.command(0x22,[0xCC])                # Sequence: display
        self.command(0x20)                       # Activate Display Update Sequence
        while(gpioRead(self._busy)==1): time.sleep(0.001)

    def sleep(self):
        self.command(0x10,[0x01])                # Deep sleep mode

    def close(self):
        pass
